<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Конспект «Массивы и функции в PHP»</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <main class="container">
        <h1>Конспект «Массивы и функции в PHP»</h1>
        <div class="content">
            <h2>Функции</h2>
            <p><b>Функция</b>&nbsp;— это фрагмент кода, который можно написать один раз, а&nbsp;затем использовать,
                когда потребуется.</p>
            <p>Прежде чем использовать функцию, её&nbsp;<i>объявляют</i> с&nbsp;помощью ключевого слова
                <code>function</code>. После него указывают имя функции. Оно должно начинаться с&nbsp;латинской буквы
                или знака подчёркивания.</p>
            <p>После имени функции пишут круглые скобки, а&nbsp;затем&nbsp;— тело функции в&nbsp;фигурных скобках.
                В&nbsp;теле функции находится тот код, который функция будет выполнять.</p>
            <pre><code>function my_func() {
  keks_log('Я функция my_func');
}</code></pre>
            <p>Когда функцию объявляют, PHP запоминает её, но&nbsp;при этом код внутри фигурных скобок
                не&nbsp;выполняется. Чтобы его выполнить, функцию надо <i>вызвать</i>.</p>
            <p>Чтобы вызвать функцию, пишем её&nbsp;имя и&nbsp;круглые скобки:</p>
            <pre><code>my_func(); // Выведет: "Я функция my_func"</code></pre>
            <p>Функцию можно вызывать любое число раз.</p>
            <p>Переменные, объявленные внутри функции, доступны только внутри этой функции. А&nbsp;внешние переменные,
                наоборот, внутри функции не&nbsp;видны. Это называется областью видимости. Вы&nbsp;можете узнать
                о&nbsp;ней больше в&nbsp;<a href="https://www.php.net/manual/ru/language.variables.scope.php"
                    target="_blank" rel="nofollow noopener">документации</a>.</p>
            <p>Мы&nbsp;можем вызывать одну функцию внутри другой.</p>
            <h2>Аргументы функции</h2>
            <p>Аргументы позволяют передавать функции разные данные и&nbsp;влиять на&nbsp;результат её&nbsp;работы.
                Аргументы&nbsp;указывают при объявлении функции в&nbsp;круглых скобках. Их&nbsp;может быть сколько
                угодно. Если аргументов несколько, они указываются через запятую.</p>
            <p>Аргументы похожи на&nbsp;переменные. Они тоже хранят значения, и&nbsp;их&nbsp;имена должны начинаться
                со&nbsp;знака доллара. Аргументы можно использовать только в&nbsp;теле функции:</p>
            <pre><code>function my_func($number_1, $number_2) {
  keks_log($number_1 - $number_2);
}</code></pre>
            <p>Значения аргументов указывают в&nbsp;круглых скобках при вызове функции. Их&nbsp;перечисляют через
                запятую <b>в&nbsp;том&nbsp;же порядке</b>, что и&nbsp;аргументы при объявлении функции.</p>
            <pre><code>my_func(3, 1); // Выведет: "2"
my_func(1, 3); // Выведет: "-2"</code></pre>
            <h2>Функция возвращает значение</h2>
            <p>Функции могут не&nbsp;только принимать данные, но&nbsp;и&nbsp;<b>возвращать</b> их. Чтобы указать, какое
                значение должна вернуть функция, используют ключевое слово <code>return</code>:</p>
            <pre><code>function my_func($number_1, $number_2) {
  return $number_1 - $number_2;
}</code></pre>
            <p>Когда функцию вызовут, на&nbsp;её&nbsp;место в&nbsp;коде подставится то&nbsp;значение, которое она
                вернёт.</p>
            <pre><code>&lt;!-- Вызываем функцию в шаблоне --&gt;
&lt;p&gt;&lt;?= my_func(3, 1) ?&gt;&lt;/p&gt;

&lt;!-- Результат  --&gt;
&lt;p&gt;2&lt;/p&gt;</code></pre>
            <p>Вернув значение, функция прекратит работу. Последующий код <b>в&nbsp;теле</b> функции PHP проигнорирует.
            </p>
            <pre><code>function my_func($number_1, $number_2) {
  return $number_1 - $number_2;

  // Код на следующей строке никогда не будет исполнен
  keks_log('Есть ли жизнь после return?');
}</code></pre>
            <p>Функция может ничего не&nbsp;возвращать или вернуть <b>одно</b> любое значение: число, строку, массив
                и&nbsp;так далее.</p>
            <h2>Встроенные функции</h2>
            <p><b>Встроенные функции</b>&nbsp;— это функции, которые написали создатели&nbsp;PHP. Это часть языка,
                поэтому их&nbsp;не&nbsp;нужно объявлять, прежде чем использовать. В&nbsp;PHP существуют тысячи готовых
                функций. Нет нужды заучивать их&nbsp;наизусть, ведь всегда можно заглянуть в&nbsp;<a
                    href="https://www.php.net/manual/ru/funcref.php" target="_blank"
                    rel="nofollow noopener">документацию</a>.</p>
            <p><b>Колбэком</b> называют функцию, которую передают в&nbsp;качестве аргумента другой функции. Колбэки
                не&nbsp;являются встроенными функциями, их&nbsp;пишут сами разработчики.</p>
            <h3>uasort</h3>
            <p>Встроенная функция <code>uasort</code> сортирует массив. Эта функция принимает два аргумента: массив,
                который нужно отсортировать, и&nbsp;имя функции-колбэка.</p>
            <pre><code>uasort($array, 'callback');</code></pre>
            <p>Функция-колбэк, которую мы&nbsp;передаём <code>uasort</code>, должна принимать два аргумента
                и&nbsp;возвращать число: положительное число, если первый аргумент больше, отрицательное число, если
                больше второй аргумент, и&nbsp;ноль, если аргументы равны.</p>
            <p>Во&nbsp;время вызова <code>uasort</code> передаёт в&nbsp;колбэк по&nbsp;двое элементы массива, узнаёт,
                какой из&nbsp;них больше, и&nbsp;сортирует массив по&nbsp;возрастанию: от&nbsp;меньшего к&nbsp;большему.
            </p>
            <h3>array_slice</h3>
            <p>Функция <code class="nowrap">array_slice</code> принимает массив, копирует его часть и&nbsp;возвращает
                её&nbsp;в&nbsp;виде нового массива. Массив, который передали функции, при этом не&nbsp;изменяется.</p>
            <p>Функция принимает четыре аргумента:</p>
            <ul>
                <li>исходный массив,</li>
                <li>порядковый номер элемента, с&nbsp;которого начнётся копирование,</li>
                <li>количество элементов, которые нужно скопировать,</li>
                <li>булево значение&nbsp;— нужно&nbsp;ли сохранять ключи исходного массива.</li>
            </ul>
            <pre><code>$new_array = array_slice($array, $first_element, $length, $preserve_keys);</code></pre>
            <h3>array_filter</h3>
            <p>В&nbsp;PHP есть встроенная функция фильтрации&nbsp;— <code class="nowrap">array_filter</code>. Она
                принимает два аргумента: исходный массив и&nbsp;функцию-колбэк&nbsp;— и&nbsp;возвращает новый массив.
                Исходный массив при этом не&nbsp;изменяется.</p>
            <pre><code>$filtered_array = array_filter($array, 'callback');</code></pre>
            <p>Согласно <a href="https://www.php.net/manual/ru/function.array-filter.php" target="_blank"
                    rel="nofollow noopener">документации</a>, колбэк должен принимать элемент исходного массива
                и&nbsp;возвращать булево значение: <code>true</code>, если этот элемент нужно включить в&nbsp;новый
                массив, и&nbsp;<code>false</code>, если не&nbsp;нужно.</p>
            <h3>array_rand</h3>
            <p>Для получения случайных элементов из&nbsp;массива, используем функцию <code
                    class="nowrap">array_rand</code>. Она принимает исходный массив и&nbsp;количество случайных
                элементов, которые мы&nbsp;хотим получить.</p>
            <pre><code>$random = array_rand($array, $number_of_elements);</code></pre>
            <p>Если второй аргумент&nbsp;— единица, функция вернёт один случайный ключ. Если второй аргумент больше
                единицы, функция вернёт массив со&nbsp;случайными&nbsp;ключами.</p>
            <p>Функция <code class="nowrap">array_rand</code> выбирает случайные элементы, но&nbsp;возвращает
                их&nbsp;в&nbsp;том порядке, в&nbsp;каком они идут в&nbsp;исходном массиве.</p>
            <h3>shuffle</h3>
            <p>Встроенная функция <code>shuffle</code> перемешивает массив. Функция принимает массив и&nbsp;выстраивает
                его элементы в&nbsp;случайном порядке. Будьте осторожны, функция <code>shuffle</code> изменяет
                переданный ей&nbsp;массив и&nbsp;не&nbsp;сохраняет ключи. С&nbsp;ассоциативными массивами её&nbsp;лучше
                не&nbsp;использовать.</p>
            <pre><code>shuffle($array);</code></pre>
            <h2>Объединение массивов</h2>
            <p>В&nbsp;PHP массивы можно объединить с&nbsp;помощью знака плюс:</p>
            <pre><code>$big_array = $array_1 + $array_2;</code></pre>
            <p>В&nbsp;результате получится один массив, который включает элементы как из&nbsp;первого, так
                и&nbsp;из&nbsp;второго массива. При этом порядок элементов и&nbsp;их&nbsp;ключи сохранятся.</p>
            <p>Если у&nbsp;нескольких элементов окажутся одинаковые ключи, то&nbsp;значение возьмётся из&nbsp;того
                массива, который идёт раньше. Перед объединением убедитесь, что ключи в&nbsp;массивах не&nbsp;совпадают
                или что одинаковым ключам соответствуют одинаковые значения.</p>
        </div>
    </main>
</body>

</html>